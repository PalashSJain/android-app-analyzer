package rq2;

import main.Config;

import java.sql.*;
import java.util.*;

/**
 * Created by Palash on 4/25/2017.
 */
public class VulnerabilityScorer {
    private HashMap<Integer, Integer> repo_release;
    private HashMap<Integer, Integer> library_release;
    private Connection connection;
    private static final String DB_URL = "jdbc:sqlite:P:\\dev\\android-app-analyzer\\data\\AAA.db";

    VulnerabilityScorer() {
        Config.initialize();
        repo_release = new HashMap<>();
        library_release = new HashMap<>();
    }

    public static void main(String[] args) {
        new VulnerabilityScorer().start();
    }

    private void start() {
        try {
            connect();
            createTable();
            pull();
            disconnect();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void createTable() {
        String qVulnScores = "Create table if not exists VulnerabilityScores(" +
                "vuln_score_id INTEGER PRIMARY KEY, " +
                "repository_id INT, " +
                "release_id INT, " +
                "num INT, " +
                "total_score INT, " +
                "vuln_score INT," +
                "FOREIGN KEY (repository_id) REFERENCES Repository (repository_id), " +
                "FOREIGN KEY (release_id) REFERENCES Release (release_id))";

        Statement stmt = null;
        try {
            stmt = connection.createStatement();
            stmt.executeUpdate(qVulnScores);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void pull() {
        for (int repository_id = 1; repository_id <= Config.getMaxRepositories(); repository_id++) {
            Statement stmt;
            try {

                String qRelease = "select release_id from Release where repository_id=" + repository_id;
                stmt = connection.createStatement();
                ResultSet rsReleases = stmt.executeQuery(qRelease);
                Set<Node> pre = new HashSet<>();
                Set<Node> cur = new HashSet<>();
                Set<Node> all = new HashSet<>();
                int releaseCount = 0;
                while (rsReleases.next()) {
                    releaseCount++;
                    int release_id = rsReleases.getInt("release_id");
                    int lCount = 0;
                    int vLCount = 0;

                    String qNames = "select Name, Vulnerable from Library where release_id=" + release_id;
                    stmt = connection.createStatement();
                    ResultSet rsNames = stmt.executeQuery(qNames);
                    while (rsNames.next()) {
                        boolean isVulnerable = rsNames.getBoolean("Vulnerable");
                        String name = rsNames.getString("Name");
                        if (!pre.contains(name)) {
                            if (isVulnerable) {
                                vLCount++;
                            }
                            lCount++;
                        }
                        Node n = new Node(name, isVulnerable);
                        cur.add(n);
                        all.add(n);
                    }

                    for (Node lib : pre) {
                        if (!cur.contains(lib)) {
                            if (lib.isVulnerable()) {
                                vLCount++;
                            }
                            lCount++;
                        }
                    }

                    pre.addAll(cur);
                    float max = (pre.isEmpty() ? 1 : pre.size()) * releaseCount;
                    float totalScore = (100 * lCount) / max;
                    float vulnScore = (100 * vLCount) / max;
                    if (releaseCount != 1)
                        addToVulnerabilityScores(releaseCount, repository_id, totalScore, vulnScore, release_id);

                    pre.clear();
                    pre.addAll(cur);
                    cur = new HashSet<>();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }

        }
    }

    private void addToVulnerabilityScores(int num, int repository_id, float totalScore, float vulnScore, int release_id) {
        String query = "Insert into VulnerabilityScores (num, repository_id, total_score, vuln_score, release_id) values(" + num + "," + repository_id + "," + totalScore + "," + vulnScore + "," + release_id + ")";
        Statement stmt;
        try {
            stmt = connection.createStatement();
            stmt.execute(query);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void disconnect() throws SQLException {
        try {
            if (connection != null)
                connection.close();
        } catch (SQLException se) {
            se.printStackTrace();
        }
    }

    private void connect() throws SQLException {
        connection = DriverManager.getConnection(DB_URL);
    }

    private class Node {

        private final boolean isVulnerable;
        private final String name;

        public Node(String name, boolean isVulnerable) {
            this.name = name;
            this.isVulnerable = isVulnerable;
        }

        public boolean isVulnerable() {
            return isVulnerable;
        }

        public String getName() {
            return name;
        }

        public boolean equals(Node o) {
            return (o instanceof Node) && (o.getName()).equals(this.getName());
        }

        public int hashCode() {
            return name.hashCode();
        }
    }

}
